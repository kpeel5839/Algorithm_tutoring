# 10989번 문제
### 전형적인 특수 정렬을 이용한 O(n) 복잡도를 요구하는 문제이다.

보통 정렬을 요하는 문제는 입력의 크기가 100만 이하인 경우가 많지만 이 문제의 경우에는 , 무려 1000만의 크기의 입력이 주어진다.

그렇기 때문에 , Radix Sort 혹은 Counting Sort 가 필요하다.
하지만 자릿수가 5자리 이하로 주어져 있긴 하지만 , 시간면으로 따졌을 때 , Radix Sort 로 풀 이유는 없어보이기에 , Counting Sort 로 푸는 것이 가장 효과적인 문제 풀이 방식이다.

이 문제의 풀이 방식은 이러하다.
일단 a 배열로 입력들을 받고 , 정렬의 결과를 저장할 b 배열을 선언한다.
그리고 각 숫자의 개수를 저장할 c 배열을 선언한다. (이 때 , 0 ~ 10000 범위의 숫자를 담기 위해서는 꼭 10001 로 선언을 해주어야 한다.)

그러고서 그냥 c[a[i]] 라는 구문을 이용하여서 a[i] 각 숫자들의 개수를 세주고 
for(int i = 2; i < c.length; i++) c[i] = c[i] + c[i - 1]; 처럼 누적합을 통해 각 숫자들의 적절한 위치를 찾아 준다.

그리고서 b[c[a[i]] - 1] = a[i] , c[a[i]]-- 를 를 통해서 , 각 숫자들의 적절한 위치를 찾아 b 배열에 삽입하고 , 이 소스코드 같은 경우에는 output.write(number + "\n") 으로 답을 출력하였다.

이런식으로 굉장히 특수하게 각 값들의 한도가 주어지는 경우에는 이러한 방법을 사용할 수 있다. (Counting Sort 를 이해하고 연습하기에는 좋은 문제로 보임)
